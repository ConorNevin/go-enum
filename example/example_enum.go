// Code generated by go-enum
// DO NOT EDIT!

package example

import (
	"fmt"
)

const (
	// AnimalCat is a Animal of type Cat
	AnimalCat Animal = iota
	// AnimalDog is a Animal of type Dog
	AnimalDog
	// AnimalFish is a Animal of type Fish
	AnimalFish
)

const _AnimalName = "CatDogFish"

var _AnimalIndex = [...]uint8{0, 3, 6, 10}

func (i Animal) String() string {
	if i < 0 || i >= Animal(len(_AnimalIndex)-1) {
		return fmt.Sprintf("Animal(%d)", i)
	}
	return _AnimalName[_AnimalIndex[i]:_AnimalIndex[i+1]]
}

var _AnimalValue = map[string]int32{

	"Cat":  0,
	"Dog":  1,
	"Fish": 2,
	"cat":  0,
	"dog":  1,
	"fish": 2,
}

// ParseAnimal attempts to convert a string to a Animal
func ParseAnimal(name string) (Animal, error) {
	if x, ok := _AnimalValue[name]; ok {
		return Animal(x), nil
	}
	return Animal(0), fmt.Errorf("%s is not a valid Animal", name)
}

func (x *Animal) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

func (x *Animal) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAnimal(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ModelToyota is a Model of type Toyota
	ModelToyota Model = iota
	// ModelChevy is a Model of type Chevy
	ModelChevy
	// Skipped value
	_
	// ModelFord is a Model of type Ford
	ModelFord
)

const _ModelName = "ToyotaChevyFord"

var _ModelIndex = [...]uint8{0, 6, 11, 15}

func (i Model) String() string {
	if i < 0 || i >= Model(len(_ModelIndex)-1) {
		return fmt.Sprintf("Model(%d)", i)
	}
	return _ModelName[_ModelIndex[i]:_ModelIndex[i+1]]
}

var _ModelValue = map[string]int32{

	"Toyota": 0,
	"Chevy":  1,
	"Ford":   3,
	"toyota": 0,
	"chevy":  1,
	"ford":   3,
}

// ParseModel attempts to convert a string to a Model
func ParseModel(name string) (Model, error) {
	if x, ok := _ModelValue[name]; ok {
		return Model(x), nil
	}
	return Model(0), fmt.Errorf("%s is not a valid Model", name)
}

func (x *Model) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

func (x *Model) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseModel(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
